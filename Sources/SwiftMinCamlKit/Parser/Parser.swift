// This file is automatically generated by Citron version 1.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift.
//
// The authors of Citron disclaim copyright to the source code in this file.

// Parser class

import CitronKit

class Parser: CitronParser {
    // Types

    typealias CitronSymbolCode = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolCode {
        case ADD = 1
        case SUB = 2
        case MUL = 3
        case DIV = 4
        case INT = 5
        case FLOAT = 6
        case BOOL = 7
    }

    typealias CitronToken = Token

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy4(Expr)
    }

    typealias CitronResult = Expr

    // Counts

    let yyNumberOfSymbols: Int = 10
    let yyNumberOfStates: Int = 8

    // Action tables

    let yyLookaheadAction: [(CitronSymbolCode, CitronParsingAction)] = [
        /*   0 */ (0, .RD(0)), (1, .SH(4)), (2, .SH(3)), (3, .SH(2)), (4, .SH(1)),
        /*   5 */ (9, .RD(7)), (5, .SR(1)), (6, .SR(2)), (7, .SR(3)), (10, .RD(2)),
        /*  10 */ (8, .ACCEPT), (9, .SH(5)), (3, .SH(2)), (4, .SH(1)), (9, .RD(6)),
        /*  15 */ (9, .SH(6)), (9, .SH(7)),
    ]

    let yyShiftUseDefault: Int = 17
    let yyShiftOffsetMin: Int = 0
    let yyShiftOffsetMax: Int = 9
    let yyShiftOffset: [Int] = [
        /*     0 */ 1, 1, 1, 1, 1, 0, 9, 9,
    ]

    let yyReduceUseDefault: Int = -5
    let yyReduceOffsetMin: Int = -4
    let yyReduceOffsetMax: Int = 7
    let yyReduceOffset: [Int] = [
        /*     0 */ 2, -4, 5, 6, 7,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
        /*     0 */ .ERROR, .ERROR, .ERROR, .ERROR, .ERROR,
        /*     5 */ .ERROR, .RD(5), .RD(4),
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolCode] = []

    // Wildcard

    let yyWildcard: CitronSymbolCode? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolCode, nrhs: UInt)] = [
        (lhs: 8, nrhs: 1),
        (lhs: 9, nrhs: 1),
        (lhs: 9, nrhs: 1),
        (lhs: 9, nrhs: 1),
        (lhs: 9, nrhs: 3),
        (lhs: 9, nrhs: 3),
        (lhs: 9, nrhs: 3),
        (lhs: 9, nrhs: 3),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule, symbolCode: CitronSymbolCode, symbol: CitronSymbol)] = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack),
    ]
    var maxStackSize: Int?
    // Tracing

    var isTracingEnabled: Bool = false
    let yySymbolName: [String] = [
        "$", "ADD", "SUB", "MUL",
        "DIV", "INT", "FLOAT", "BOOL",
        "root", "expr",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "root ::= expr(e)",
        /*   1 */ "expr ::= INT(t)",
        /*   2 */ "expr ::= FLOAT(t)",
        /*   3 */ "expr ::= BOOL(t)",
        /*   4 */ "expr ::= expr(lhs) ADD expr(rhs)",
        /*   5 */ "expr ::= expr(lhs) SUB expr(rhs)",
        /*   6 */ "expr ::= expr(lhs) MUL expr(rhs)",
        /*   7 */ "expr ::= expr(lhs) DIV expr(rhs)",
    ]

    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch ruleNumber {
        case 0: /* root ::= expr(e) */
            func codeBlockForRule0(e: Expr) throws -> Expr {
                return e
            }
            if case let .yy4(e) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule0(e: e))
            }
        case 1: /* expr ::= INT(t) */
            func codeBlockForRule1(t: Token) throws -> Expr {
                return .int(t.asInt())
            }
            if case let .yy0(t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule1(t: t))
            }
        case 2: /* expr ::= FLOAT(t) */
            func codeBlockForRule2(t: Token) throws -> Expr {
                return .float(t.asFloat())
            }
            if case let .yy0(t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule2(t: t))
            }
        case 3: /* expr ::= BOOL(t) */
            func codeBlockForRule3(t: Token) throws -> Expr {
                return .bool(t.asBool())
            }
            if case let .yy0(t) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule3(t: t))
            }
        case 4: /* expr ::= expr(lhs) ADD expr(rhs) */
            func codeBlockForRule4(lhs: Expr, rhs: Expr) throws -> Expr {
                return .add(lhs: lhs, rhs: rhs)
            }
            if case let .yy4(lhs) = yySymbolOnStack(distanceFromTop: 2),
                case let .yy4(rhs) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule4(lhs: lhs, rhs: rhs))
            }
        case 5: /* expr ::= expr(lhs) SUB expr(rhs) */
            func codeBlockForRule5(lhs: Expr, rhs: Expr) throws -> Expr {
                return .sub(lhs: lhs, rhs: rhs)
            }
            if case let .yy4(lhs) = yySymbolOnStack(distanceFromTop: 2),
                case let .yy4(rhs) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule5(lhs: lhs, rhs: rhs))
            }
        case 6: /* expr ::= expr(lhs) MUL expr(rhs) */
            func codeBlockForRule6(lhs: Expr, rhs: Expr) throws -> Expr {
                return .sub(lhs: lhs, rhs: rhs)
            }
            if case let .yy4(lhs) = yySymbolOnStack(distanceFromTop: 2),
                case let .yy4(rhs) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule6(lhs: lhs, rhs: rhs))
            }
        case 7: /* expr ::= expr(lhs) DIV expr(rhs) */
            func codeBlockForRule7(lhs: Expr, rhs: Expr) throws -> Expr {
                return .div(lhs: lhs, rhs: rhs)
            }
            if case let .yy4(lhs) = yySymbolOnStack(distanceFromTop: 2),
                case let .yy4(rhs) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy4(try codeBlockForRule7(lhs: lhs, rhs: rhs))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case let .yy4(result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }
}
